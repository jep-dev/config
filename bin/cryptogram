#!/usr/bin/zsh

function unchanged(){
	out=""
	sub0="$1"
	sub0=$(sed 's/[a-z]/& /g' <<<$sub0)
	sub1="${2:-$sub0}"
	for ((i=0; i<${#sub0}; i++)); do
		if [[ "${sub0[i]}" -eq "${sub1[i]}" ]]; then
			out="${out}${sub0[i]}"
		fi
	done
	echo $out
}

# usage: minimax i... | read min max
function minimax(){
	least=0
	most=0
	for i ($@) { if [[ "$most" -lt "$i" ]]; then most=$i; fi }
	least=$most
	for i ($@) { if [[ "$i" -lt "$least" ]]; then least=$i; fi }
	echo $least $most
}

function frequency(){
	key="$1"
	line="${2:-}"
	if [ "x$line" = "x" ]; then
		read line
	fi
	if ! [ "x$line" = "x" ]; then
		ct=0;
		for ((k=0;k<${#line};k++)) {
			c=${line[k]}
			[ "x$c" = "x$key" ] && let 'ct++'
		}
		echo -n "$ct "
	fi
	echo
}

function frequencies(){
	read line && for arg ($@) frequency $arg "$line"
}

function exclude(){
	read line && {
		excluded=false
		for k ($line) {
			for arg ($@) [ "$k" = "$arg" ] && { excluded=true; break; }
			if ! $excluded; then echo -n "$k"; fi
		}
		echo
	}
}
function include(){
	read line && {
		included=false
		for k ($line) {
			for arg ($@) [ "$k" = "$arg" ] && { included=true; break; }
			if $included; then echo -n "$k"; fi
		}
		echo
	}
}

function static(){
	out=()
	#while read i j; do
	for i j ($@) {
		if [[ "$i" -eq "$j" ]]; then
			out+=("$i")
		fi
	}
	echo $out
}

# Pops the (optional) head, then appends it to the (optional) tail.
# (a...)' = (a...); (a, b...)' = (b..., a)
function rotate(){
	a="${1:-}"
	[[ $# -gt 0 ]] && shift
	b="${@:-}"
	echo "$b" "$a"
}
# Given N and M (optional) args, rotates the args forward N' times ( 0 <= N' < M ).
function rotate_n(){
	N="$1"
	if [[ $# -ge 2 ]]; then
		shift
		M=$#
		# N % 0 is undefined
		if [[ $N -lt 0 ]]; then
			N=$((((N%M)+M)%M))
		fi
		case $N in
			0) echo "$@"; ;;
			1) rotate $@; ;;
			*) rotate_n $((N-1)) $(rotate $@); ;;
		esac
	else
		echo "$@"
	fi
}

showQuestion=true
showAnswer=false
showKey=false

while [[ $# -ge 1 ]]; do
	met=false
	case "$1" in
		--question|-q) showQuestion=true; ;;
		--noquestion|-nq) showQuestion=false; ;;
		--key|-k) showKey=true; ;;
		--nokey|-nk) showKey=false; ;;
		--answer|-a) showAnswer=true; ;;
		--noanswer|-na) showAnswer=false; ;;
		*) met=true; ;;
	esac
	if $met; then break; fi
	shift
done

# Not a superfluous cat, look carefully
cat ${@:-} | while read quote && read attr; do
	# Formatting
	quote=$(tr -d '\r' <<<$quote)
	attr=$(tr -d '\r' <<<$attr)

	# Original values A=(Ai...) and I=sequence (i...)
	lc1=({a..z})
	uc1=${(U)lc1};
	i1=({1..${#lc1}})

	# Displaced values B=(Aj...) and sequence J={j...}
	lc2=()
	i2=($(shuf -e $i1))
	for i ($i2) lc2+=(${lc1[i]})
	uc2="${(U)lc2}"

	# Interleaved sequence IJ={i, j, ...} and unchanged subsequence DIJ of IJ
	i12=(${i1:^i2})
	s12=($(static $i12))

	s13=()
	i3=($i2)
	lc3=($lc2)
	if [[ ${#s12} -eq 0 ]]; then
	elif [[ ${#s12} -eq 1 ]]; then
		i=${s12[1]}; j=$((i-1))
		if [[ $i -eq 1 ]]; then j=2; fi
		ci=${lc2[i]}; cj=${lc2[j]}
		lc3[i]=$cj; lc3[j]=$ci
		i3[i]=$j; i3[j]=$i
	elif [[ ${#s12} -eq 2 ]]; then
		i=${s12[1]}; j=${s12[2]};
		ci=${lc2[i]}; cj=${lc2[j]};
		lc3[i]="$cj"; lc3[j]="$ci"
		i3[i]=$j; i3[j]=$i
	else
		i3=($(rotate "$i12"))
		s13=($(rotate "$s12")) # = ({b..z} a)
		for i j (${s1:^s3}) {
			i3[i]="$j"; lc3[i]=${lc2[j]}
			i3[j]="$i"; lc3[j]=${lc2[i]}
		}
		i13=(${i1:^i3})
		s13=($(static $i13))
	fi
	i13=(${i1:^i3}); uc3="${(U)lc3}"
	s13=($(static $i13))

	c1="$uc1$lc1"
	c2="$uc2$lc2"
	c3="$uc3$lc3"

	quote12=$(tr "$c1" "$c2" <<<"$quote");   attr12=$(tr "$c1" "$c2" <<<"$attr");
	quote21=$(tr "$c2" "$c1" <<<"$quote12"); attr21=$(tr "$c2" "$c1" <<<"$attr12");
	quote13=$(tr "$c1" "$c3" <<<"$quote");   attr13=$(tr "$c1" "$c3" <<<"$attr");
	quote31=$(tr "$c3" "$c1" <<<"$quote13"); attr31=$(tr "$c3" "$c1" <<<"$attr13");

	if $showQuestion; then echo "$quote13\n$attr13"; fi
	if $showAnswer; then echo "# $quote31\n# $attr31"; fi
	if $showKey; then echo "# $uc1\n# $uc3"; fi

done
